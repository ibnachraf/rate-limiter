// use openapi_model_generator::{generate_models, parse_openapi};
// use std::{env, fs, path::PathBuf};

// fn main() {
//     let open_api_file = "src/resources/openapi.yml";
//     let openapi_spec = fs::read_to_string(open_api_file)
//         .expect(format!("Failed to read file {}", open_api_file).as_str());
//     let openapi: openapiv3::OpenAPI = serde_yaml::from_str(&openapi_spec).expect("Failed to parse openapi spec");

//     // explore openapi and leverage quote! to generate your own code
//     //openapi.components.unwrap()....

//     // Generate models
// let (models, requests, responses) = parse_openapi(&openapi)
//     .expect("Failed to parse OpenAPI spec");
// let generated_code = generate_models(&models, &requests, &responses).expect("Failed to generate models");

// // creatre the output directory if it doesn't exist
// fs::create_dir_all("src/generated").expect("Failed to create output directory");
// // Write the generated code to a file
// let target_file = "src/generated/generated_models.rs";
// fs::write(target_file, generated_code)
//     .expect("Unable to write generated models to file");

// // Write a case match function 

// // Where models.rs lives
//     let manifest_dir = target_file;
//     let models_path = PathBuf::from(&manifest_dir);

//     // Re-run build if models.rs changes
//     println!("cargo:rerun-if-changed={}", models_path.display());

//     // Read and parse models.rs
//     let src = fs::read_to_string(&models_path)
//         .expect("Failed to read src/models.rs");

//     let file: syn::File = syn::parse_file(&src)
//         .expect("Failed to parse src/models.rs as Rust code");

//     let mut variants = Vec::new();
//     let mut match_arms = Vec::new();

//     for item in file.items {
//         if let syn::Item::Struct(s) = item {
//             let ident = s.ident;
//             let name_str = ident.to_string();

//             // Enum variant: Pet(crate::models::Pet)
//             variants.push(quote::quote! {
//                 #ident(crate::models::#ident)
//             });

//             // Match arm: "Pet" => { ... }
//             match_arms.push(quote::quote! {
//                 #name_str => {
//                     let value: crate::models::#ident = serde_json::from_str(json)?;
//                     Ok(AnyModel::#ident(value))
//                 }
//             });
//         }
//     }

//     let generated = quote::quote! {
//         // AUTO-GENERATED BY build.rs â€“ DO NOT EDIT

//         #[derive(Debug)]
//         pub enum AnyModel {
//             #(#variants),*
//         }

//         pub fn from_json_by_name(
//             type_name: &str,
//             json: &str,
//         ) -> Result<AnyModel, serde_json::Error> {
//             match type_name {
//                 #(#match_arms,)*
//                 other => panic!("Unknown type name: {}", other),
//             }
//         }
//     };

//     let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
//     let dest = PathBuf::from("generated_deser.rs");
//     fs::write(&dest, generated.to_string())
//         .expect("Failed to write generated_deser.rs");

// }


fn main() {
    // Build script can be empty for now
}
